/*
问题描述
小M最近迷上了一款弹子游戏机，规则如下：
玩家可以在版面最上方任意一个位置放置弹珠。弹珠会通过得分点时为玩家赢得分数，目标是获得尽可能高的分数。
弹子游戏机的版面由两种组成要素构成：

钉子（用 -1 表示），当弹珠碰到钉子时，有可能弹射到左下或者右下的位置。
得分点（非负整数），弹珠经过得分点时可以获得对应的分数。
如果弹珠所在的格子为空（即没有钉子或者得分点），弹珠会直接往下落。

小M想知道，在一个给定的版面布局中，他能够获得的最高分数是多少。

n 表示版面的高度。
m 表示版面的宽度。
array 是一个 n x m 的二维数组，其中：
-1 表示该位置为钉子；
0 表示该位置为空；
正整数表示该位置为得分点，值为该得分点的分数。
测试样例
样例1：

输入：n = 3 ,m = 3 ,array = [[-1, 0, -1], [100, 0, 0], [0, 50, 70]]
输出：50

样例2：

输入：n = 4 ,m = 3 ,array = [[-1, 0, -1], [0, -1, 0], [50, 100, 70], [80, 200, 50]]
输出：130

样例3：

输入：n = 5 ,m = 5 ,array = [[0, -1, 0, -1, 0], [0, 50, -1, 50, 0], [100, 0, 0, 0, 100], [0, 100, 0, 100, 0], [50, 0, 50, 0, 50]]
输出：150

动态规划问题 先从最后开始填起
*/
#include <algorithm>
#include <iostream>
#include <vector>

int solution(int n, int m, std::vector<std::vector<int>>& array) {
    // Edit your code here
    int score[n][m];
    for (int i=0; i<m; i++) 
    {
        score[n-1][i]=array[n-1][i];
        if (score[n-1][i]==-1) {
            score[n-1][i]=0;
        }
    }
    for (int i =n-2; i>=0; i--) 
    {
        for (int j=0; j<m; j++) 
        {
            if (array[i][j]==-1) 
            {
                if (j==0) score[i][j]=score[i+1][j+1];
                else if (j==m-1) score[i][j]=score[i+1][j-1];
                else
                    score[i][j]=std::max(score[i+1][j+1],score[i+1][j-1]);
            }
            else {
            score[i][j]=score[i+1][j]+array[i][j];
            }
        }
    }
    int result =0;
    for (const auto& scor : score[0]) {
        result = std::max(result,scor);
    }
    return result;
}

int main() {
    // Add your test cases here
    std::vector<std::vector<int>> array1 = {{-1, 0, -1}, {100, 0, 0}, {0, 50, 70}};
    std::vector<std::vector<int>> array2 = {{-1, 0, -1}, {0, -1, 0}, {50, 100, 70}, {80, 200, 50}};
    std::cout << (solution(3, 3,array1) == 50) << std::endl;
    std::cout << (solution(4, 3, array2) == 130) << std::endl;
    return 0;
}
